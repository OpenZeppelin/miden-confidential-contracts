# Private State Manager (PSM) Authentication Component
#
# This component provides PSM signature verification for accounts.
# It can be used standalone or in conjunction with other auth components like multisig.

use miden::active_account
use miden::native_account

# Type definitions for v0.12 syntax
type BeWord = struct @bigendian { a: felt, b: felt, c: felt, d: felt }

# IMPORTANT SECURITY NOTES
# --------------------------------------------------------------------------------
# - The selector in `PSM_SELECTOR_SLOT` controls whether the extra PSM signature
#   is enforced:
#     * PSM_ON  => exactly one valid PSM signature is required.
#     * PSM_OFF => PSM signature is skipped for that call.
#
# - `verify_psm_signature` *always* writes PSM_ON back to `PSM_SELECTOR_SLOT`
#   at the end. This means:
#     * After `update_psm_public_key` runs, the next transaction will see
#       selector = OFF and will NOT require a PSM signature.
#     * That same call to `verify_psm_signature` will set the selector to ON,
#       so all subsequent transactions WILL require a valid PSM signature
#       until the key is rotated again.
#
# - `update_psm_public_key`:
#     * Temporarily disables the PSM selector (PSM_OFF),
#     * Installs a new PSM public key in the map at `PSM_PUBLIC_KEY_MAP_SLOT`,
#     * Does not itself perform any signature checks.
#
# Storage Layout
# --------------------------------------------------------------------------------
#
# ┌─────────────────────┬───────────────┐
# │     DESCRIPTION     │     SLOT      │
# ├─────────────────────┼───────────────┤
# │ PSM SELECTOR (word) │       0       │
# │ PSM PUBLIC KEY MAP  │       1       │
# └─────────────────────┴───────────────┘
#
# - PSM_SELECTOR_SLOT (0):
#     * Stores a word that is compared against [1, 0, 0, 0] (PSM_ON).
#     * Any value ≠ PSM_ON is treated as PSM_OFF.
#
# - PSM_PUBLIC_KEY_MAP_SLOT (1):
#     * A map from a fixed key [0, 0, 0, 0] to the single PSM public key:
#         [0, 0, 0, 0] => PSM_PUBLIC_KEY
#     * PSM_PUBLIC_KEY is a RPO Falcon 512 public key represented as a word.
#
# Events
# --------------------------------------------------------------------------------
# - AUTH_UNAUTHORIZED_EVENT:
#     * Emitted when the PSM signature is missing or invalid while the selector
#       is ON.
#     * Message emitted: "invalid PSM signature".
#

# CONSTANTS
# =================================================================================================

# Slot where the PSM selector flag is stored:
# - PSM_ON  => PSM signature required
# - PSM_OFF => PSM signature skipped
const PSM_SELECTOR_SLOT = 0

# Map slot for PSM public key
# Uses exactly one PSM public key at index [0, 0, 0, 0]
# [0, 0, 0, 0] => PSM_PUBLIC_KEY
const PSM_PUBLIC_KEY_MAP_SLOT = 1

# Selector flag values
const PSM_ON = [1, 0, 0, 0]
const PSM_OFF = [0, 0, 0, 0]

# The event emitted when a signature is not found for a required signer.
const AUTH_UNAUTHORIZED_EVENT = event("miden::auth::unauthorized")

# PSM PROCEDURES
# =================================================================================================


#! Conditionally verify a "PSM" signature against a stored public key hash.
#! The condition is controlled by the selector at PSM_SELECTOR_SLOT specified above.
#!
#! Operand stack inputs: []
#! Outputs: []
#!
#! Notes:
#! - Sets PSM_SELECTOR_SLOT to PSM_ON (1)
#! - After this, transactions will require PSM signature verification
proc enable_psm
    push.PSM_ON
    # => [PSM_ON]

    push.PSM_SELECTOR_SLOT
    # => [PSM_SELECTOR_SLOT, PSM_ON]

    exec.native_account::set_item
    # => [OLD_ROOT]

    dropw
    # => []
end

#! Disable PSM verification by setting the selector to OFF.
#!
#! Operand stack inputs: []
#! Outputs: []
#!
#! Notes:
#! - Sets PSM_SELECTOR_SLOT to PSM_OFF (0)
#! - After this, transactions will NOT require PSM signature verification
proc disable_psm
    push.PSM_OFF
    # => [PSM_OFF]

    push.PSM_SELECTOR_SLOT
    # => [PSM_SELECTOR_SLOT, PSM_OFF]

    exec.native_account::set_item
    # => [OLD_ROOT]

    dropw
    # => []
end

#! Update the PSM public key.
#!
#! Operand stack inputs: []
#! Advice stack inputs:  [PUB_KEY]
#!   - PUB_KEY is the new PSM RPO Falcon 512 public key
#!
#! Notes:
#! - Stores PUB_KEY into PSM_PUBLIC_KEY_MAP_SLOT:
#!      [0, 0, 0, 0] => PSM_PUBLIC_KEY
#! - To update the key without requiring PSM signature, ensure
#!   PSM_SELECTOR_SLOT = 0 (OFF) before calling this.
pub proc update_psm_public_key
    # ------ Disable the PSM selector ------
    exec.disable_psm

    # ------ Update the PSM public key ------
    adv_loadw
    # => [PUB_KEY]

    push.0.0.0.0
    # => [MAP_KEY, PUB_KEY]
    # Note that MAP_KEY is [0, 0, 0, 0] for a single PSM_KEY

    push.PSM_PUBLIC_KEY_MAP_SLOT
    # => [index, MAP_KEY, PUB_KEY]

    exec.native_account::set_map_item
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE]

    dropw dropw
    # => []
end

#! Conditionally verify a "PSM" signature against a stored public key hash.
#! The condition is controlled by the selector at PSM_SELECTOR_SLOT.
#!
#! Inputs:  [MSG]
#! Outputs: [MSG]
#!
#! Panics if:
#! - Selector is ON but the provided PSM signature is invalid or missing.
#!
#! Notes:
#! - MSG is TX_SUMMARY_COMMITMENT provided by auth procedure
#! - If selector is OFF (0), PSM verification is skipped
#! - Selector value is read from initial storage state
pub proc verify_psm_signature(msg: BeWord)
    push.PSM_SELECTOR_SLOT
    # => [PSM_SELECTOR_SLOT, MSG]

    #! Not the initial item!
    #! But the current item updated by disable procedure
    exec.active_account::get_item
     # => [0, 0, 0, psm_selector, MSG]

    drop drop drop
    # => [psm_selector, MSG]

    push.1
    # => [1, psm_selector, MSG]

    eq # is_equal
    # [is_equal, MSG]
    debug.stack

    # ------ Conditionally verify the PSM signature ------
    if.true
        # => [MSG]
        push.1
        # [num_approvers, MSG]

        push.PSM_PUBLIC_KEY_MAP_SLOT
        # => [PSM_PUBLIC_KEY_MAP_SLOT, num_approvers, MSG]

        exec.::miden::auth::rpo_falcon512::verify_signatures
        # => [num_verified_signatures, MSG]

        push.1
        # => [1, num_verified_signatures, MSG]

        neq
        # => [is_unauthorized, MSG]
        # If signatures are non-existent the tx will fail here.
        if.true
            emit.AUTH_UNAUTHORIZED_EVENT
            push.0 assert.err="invalid PSM signature"
        end
    else
        # Return MSG
        # => [MSG]
        push.0
        # => [0, MSG]

        drop
        # => [MSG]
    end
    # => [MSG]

    # ------ Enable the PSM selector ------
    exec.enable_psm
end